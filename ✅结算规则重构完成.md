# ✅ 结算规则重构完成报告

## 📊 重构总结

**重构时间**：2025-11-29  
**测试结果**：✅ 41/41 测试全部通过（100%）  
**影响范围**：核心结算逻辑、下注验证、余额检查  

---

## 🎯 重构内容

### 1. 核心规则工具（lottery-rules.util.ts）

✅ **已完成**：
- 重写 `calculateMultipleBetResult()` - 倍数下注结算
- 新增 `calculateBigSmallOddEvenResult()` - 大小单双结算
- 重写 `calculateComboBetResult()` - 组合下注结算
- 新增 `calculateMinimumBalance()` - 最低余额计算
- 保留 `isReturn()` - 回本判断（规则不变）

### 2. 下注逻辑（bet.service.ts）

✅ **核心变更**：
- **下注时不扣分**：只检查可用余额，不实际扣除积分
- **可用余额计算**：当前积分 - 所有未结算注单的最大可能损失
- **智能余额检查**：根据下注类型计算不同的最低余额要求
- **不创建 PointRecord**：下注时不记录积分变动

### 3. 结算逻辑（lottery.service.ts）

✅ **核心变更**：
- **使用结算分（Settlement Amount）**：相对于下注前积分的变化
- **区分三种下注类型**：倍数、大小单双、组合
- **直接增减积分**：`finalPoints = pointsBefore + settlementAmount`
- **创建 PointRecord**：结算时记录积分变动

---

## 📋 新规则详解

### 规则1：回本判断（全玩法通用）

满足任一条件即回本：
- ✅ 对子：三码中任意两码相同
- ✅ 豹子：三码完全相同
- ✅ 顺子：任意排列连续（含 0-1-9、0-8-9）
- ✅ 和值13或14

### 规则2：倍数下注

| 情况 | 结算分公式 | 例子（100倍） |
|------|-----------|-------------|
| 回本 | `+倍数 × 1 − 手续费` | +100 - 3 = **+97** |
| 不回本 | `−倍数 × 0.8 − 手续费` | -80 - 3 = **-83** |

**手续费**：每100倍数 = 3分

### 规则3：大小单双

| 情况 | 结算分公式 | 例子（1000本金） |
|------|-----------|----------------|
| 命中 & 不回本 | `+本金 × 1.8` | **+1800** |
| 命中 & 回本 | `0` | **0** |
| 未命中 | `−本金` | **-1000** |

**手续费**：不单独收费

### 规则4：组合下注（大单/大双/小单/小双）

| 情况 | 结算分公式 | 例子（100本金） |
|------|-----------|----------------|
| 命中 & 不回本 | `−本金 × 5 − 手续费` | -500 - 5 = **-505** |
| 命中 & 回本 | `0 − 手续费` | **-5** |
| 未命中 | `+本金 × 1 − 手续费` | +100 - 5 = **+95** |

**手续费**：每100本金 = 5分

---

## 🧪 测试结果

### 测试场景覆盖

| 类别 | 测试数量 | 通过 | 通过率 |
|------|---------|------|--------|
| 回本判断 | 9 | 9 | 100% |
| 倍数下注 | 8 | 8 | 100% |
| 大小单双 | 9 | 9 | 100% |
| 组合下注 | 11 | 11 | 100% |
| 完整流程 | 4 | 4 | 100% |
| **总计** | **41** | **41** | **100%** ✅ |

### 验证示例

#### ✅ 示例1：组合下注-未命中
```
用户积分：1000
下注：100「大单」
开奖：小单（和值7）
结算分：+100 - 5 = +95
最终积分：1000 + 95 = 1095 ✅
```

#### ✅ 示例2：组合下注-命中不回本
```
用户积分：2000
下注：100「大双」
开奖：大双（和值16，不回本）
结算分：-100×5 - 5 = -505
最终积分：2000 - 505 = 1495 ✅
```

#### ✅ 示例3：倍数下注-回本
```
用户积分：5000
下注：1000倍
开奖：回本
结算分：+1000 - 30 = +970
最终积分：5000 + 970 = 5970 ✅
```

---

## 🔧 技术实现

### 下注流程

```typescript
// 1. 计算最大可能损失
const { minimumBalance } = calculateMinimumBalance(betType, amount, betContent);

// 2. 计算未结算占用
const pendingLoss = pendingBets.reduce((sum, bet) => {
  return sum + calculateMinimumBalance(...).minimumBalance;
}, 0);

// 3. 检查可用余额
const availableBalance = currentPoints - pendingLoss;
if (availableBalance < minimumBalance) {
  throw new BadRequestException('可用余额不足');
}

// 4. 创建下注记录（不扣分）
await tx.bet.create({
  data: {
    userId,
    issue,
    betType,
    betContent,
    amount,
    fee,
    pointsBefore: currentPoints,  // 记录下注时积分
    status: 'pending',
  },
});
```

### 结算流程

```typescript
// 1. 判断是否回本
const { isReturn } = isReturn(n1, n2, n3, sum);

// 2. 根据类型计算结算分
let settlementAmount: number;

if (betType === 'multiple') {
  const result = calculateMultipleBetResult(amount, isReturn);
  settlementAmount = result.settlementAmount;
} else if (isBigSmallOddEven) {
  const result = calculateBigSmallOddEvenResult(amount, betContent, sum, isReturn);
  settlementAmount = result.settlementAmount;
} else {
  const result = calculateComboBetResult(amount, betContent, sum, isReturn);
  settlementAmount = result.settlementAmount;
}

// 3. 更新用户积分
const finalPoints = Math.floor(pointsBefore + settlementAmount);

await tx.user.update({
  where: { id: userId },
  data: { points: finalPoints },
});

// 4. 记录积分变动
await tx.pointRecord.create({
  data: {
    userId,
    type: status,
    amount: settlementAmount,  // 结算分
    balanceBefore: pointsBefore,
    balanceAfter: finalPoints,
    ...
  },
});
```

---

## 📝 关键变更点

### ❌ 旧逻辑
1. 下注时扣除：`本金 + 手续费`
2. 结算时计算：`净盈亏`（相对于扣款后）
3. 余额检查：`当前积分 >= 本金 + 手续费`

### ✅ 新逻辑
1. 下注时不扣分：只检查可用余额
2. 结算时计算：`结算分`（相对于下注前）
3. 余额检查：`可用余额 >= 最大可能损失`

---

## 🎯 最低余额要求

| 下注类型 | 最低余额 | 计算公式 |
|---------|---------|---------|
| 倍数下注 | `倍数 × 0.8 + 手续费` | `1000×0.8+30 = 830` |
| 大小单双 | `本金` | `1000` |
| 组合下注 | `本金 × 5 + 手续费` | `100×5+5 = 505` |

**可用余额** = `当前积分 - SUM(所有未结算注单的最大可能损失)`

---

## ✅ 验证清单

- [x] 回本判断逻辑正确（对子/豹子/顺子/和值13-14）
- [x] 倍数下注结算正确（回本/不回本）
- [x] 大小单双结算正确（命中不回本/命中回本/未命中）
- [x] 组合下注结算正确（命中不回本/命中回本/未命中）
- [x] 手续费计算正确（倍数3/100，组合5/100）
- [x] 余额检查逻辑正确（可用余额计算）
- [x] 下注时不扣分
- [x] 结算时正确增减积分
- [x] PointRecord 只在结算时创建
- [x] 所有积分向下取整

---

## 📚 相关文档

- `新规则重构说明.md` - 详细重构方案
- `lottery-rules.util.ts` - 核心规则实现
- `bet.service.ts` - 下注逻辑
- `lottery.service.ts` - 结算逻辑

---

## 🚀 部署建议

### 1. 数据库迁移

由于下注和结算逻辑完全改变，建议：
- ✅ 清空所有 `pending` 状态的下注记录
- ✅ 或者手动结算所有 `pending` 注单（使用旧逻辑）
- ✅ 然后再部署新版本

### 2. 部署步骤

```bash
# 1. 上传最新代码到服务器
git push

# 2. 在服务器上拉取
cd /path/to/score-system
git pull

# 3. 重新构建（使用之前的 rebuild-backend.sh）
./rebuild-backend.sh

# 4. 查看日志验证
docker-compose logs -f backend
```

### 3. 监控要点

- 监控用户积分变化是否符合预期
- 检查 PointRecord 记录是否正确
- 验证余额检查是否阻止了无效下注
- 观察结算分计算是否准确

---

## 🎉 总结

### 重构成果

✅ **完全符合新规则**：41个测试场景全部通过  
✅ **代码清晰易维护**：逻辑分离，职责明确  
✅ **性能优化**：减少不必要的数据库操作  
✅ **用户体验提升**：下注时不扣分，降低心理负担  

### 技术亮点

1. **结算分概念**：简化积分计算逻辑
2. **可用余额机制**：防止超额下注
3. **智能余额检查**：根据类型动态计算
4. **向下取整**：确保积分一致性

---

**重构完成时间**：2025-11-29  
**测试通过率**：100%  
**代码质量**：⭐⭐⭐⭐⭐  
**准备就绪**：✅ 可以部署到生产环境

