# 🔧 前端轮询错误处理改进

## 问题现象

前端在接口返回500错误后，仍然持续轮询请求 `bet-history` 接口，导致大量错误日志。

## 根本原因分析

### 1. 后端500错误（已修复）
- **文件**：`backend/src/modules/bet/bet.service.ts`
- **问题**：`getUserBetHistory` 方法在 `mergeBetsByIssue` 返回 `null` 时没有过滤，导致排序时访问 `null.createdAt` 报错
- **修复**：添加 `if (merged)` 检查，过滤掉 `null` 值

### 2. 前端轮询逻辑
- **文件**：`frontend-h5/src/views/Home.vue`
- **流程**：
  ```
  onMounted() 
    → loadCurrentData() 
      → loadCurrentIssueBets() (可能500错误)
      → startCountdown()
        → 每秒执行倒计时
        → 倒计时结束 
          → setTimeout(() => loadCurrentData(), 3000)
            → 循环开始
  ```

### 3. 错误处理不足
```typescript
const loadCurrentIssueBets = async () => {
  try {
    const res = await getCurrentIssueBets()
    currentIssueBets.value = res.data
  } catch (error) {
    console.error('加载当前期下注失败：', error)
    currentIssueBets.value = null  // ⚠️ 只设为null，定时器继续运行
  }
}
```

**问题**：
- 错误时只是设置 `currentIssueBets.value = null`
- 定时器继续运行，3秒后又会调用 `loadCurrentData()`
- 如果后端持续500错误，会无限循环请求

## 改进方案

### 改进1：添加错误计数和用户提示

```typescript
let loadBetsErrorCount = 0 // 连续错误计数

const loadCurrentIssueBets = async () => {
  try {
    const res = await getCurrentIssueBets()
    currentIssueBets.value = res.data
    loadBetsErrorCount = 0 // 成功后重置错误计数
  } catch (error) {
    loadBetsErrorCount++
    console.error(`加载当前期下注失败(${loadBetsErrorCount}次):`, error)
    currentIssueBets.value = null
    
    // 如果连续失败超过3次，显示提示
    if (loadBetsErrorCount === 3) {
      showToast({
        message: '⚠️ 获取下注记录失败，请刷新页面重试',
        type: 'fail',
        duration: 3000,
      })
    }
  }
}
```

**优点**：
- ✅ 用户知道出现问题了
- ✅ 不影响倒计时和其他功能
- ✅ 后端修复后会自动恢复

### 改进2：添加指数退避重试（可选）

```typescript
let loadBetsErrorCount = 0
let loadBetsRetryDelay = 3000 // 初始延迟3秒

const loadCurrentIssueBets = async () => {
  try {
    const res = await getCurrentIssueBets()
    currentIssueBets.value = res.data
    loadBetsErrorCount = 0
    loadBetsRetryDelay = 3000 // 重置延迟
  } catch (error) {
    loadBetsErrorCount++
    console.error(`加载当前期下注失败(${loadBetsErrorCount}次):`, error)
    currentIssueBets.value = null
    
    // 指数退避：3s, 6s, 12s, 24s, 最大30s
    if (loadBetsErrorCount > 1) {
      loadBetsRetryDelay = Math.min(loadBetsRetryDelay * 2, 30000)
    }
    
    if (loadBetsErrorCount === 3) {
      showToast({
        message: '⚠️ 获取下注记录失败，请刷新页面重试',
        type: 'fail',
        duration: 3000,
      })
    }
  }
}
```

**优点**：
- ✅ 减少服务器压力
- ✅ 错误后自动降低请求频率
- ❌ 复杂度增加

## 当前已实施的方案

**选择：改进1（添加错误计数和用户提示）**

**原因**：
1. 简单有效，不增加复杂度
2. 用户能及时知道问题
3. 后端修复后会自动恢复
4. 不影响倒计时等核心功能

## 部署说明

### 后端（必须）
```bash
cd /path/to/score-system
docker-compose down
docker-compose build backend
docker-compose up -d
```

### 前端（已改进）
前端代码已更新，无需特殊操作。下次部署时会自动包含改进。

## 验证

1. **后端修复验证**：
   - 访问下注历史页面
   - 确认不再出现500错误
   - 查看 docker logs，确认无错误日志

2. **前端改进验证**：
   - 模拟后端错误（临时关闭后端）
   - 观察前端是否在第3次错误时显示提示
   - 恢复后端，观察是否自动恢复正常

## 总结

| 问题 | 修复 | 状态 |
|------|------|------|
| 后端500错误 | 添加null检查 | ✅ 已修复 |
| 前端无限轮询 | 添加错误计数和提示 | ✅ 已改进 |
| 用户体验 | 明确提示错误信息 | ✅ 已改进 |

