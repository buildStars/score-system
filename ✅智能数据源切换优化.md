# ✅ 智能数据源切换优化

## 📝 问题描述

**旧逻辑**：只要连续3次返回相同期号，就切换数据源

**问题**：
```
开奖前 00:00:00 → 期号 3365774
开奖前 00:00:05 → 期号 3365774 (计数1)
开奖前 00:00:10 → 期号 3365774 (计数2)
开奖前 00:00:15 → 期号 3365774 (计数3)
⚠️ 错误切换到下一个数据源！
```

**本质问题**：开奖前返回相同期号是**正常的**，不应该触发切换！

---

## ✅ 新逻辑（智能检测）

### 核心思想
**只有在预期开奖时间后，连续返回相同期号才算异常**

### 判断逻辑
```typescript
// 1. 记录获取新期号的时间
this.lastFetchTime = now;

// 2. 判断是否已超过预期开奖时间
const isAfterExpectedDraw = (now - this.lastFetchTime) >= DRAW_INTERVAL;
// DRAW_INTERVAL = 210秒（3分30秒）

// 3. 只有开奖后返回相同期号才计数
if (相同期号 && isAfterExpectedDraw) {
  staleCountAfterExpected++; // ← 只在开奖后计数
}
```

---

## 📊 工作流程

### 场景1：开奖前（正常）

```
时间线:
├─ 00:00:00  获取到期号 3365774 (新期号，记录时间)
│             lastFetchTime = 00:00:00
│             staleCountAfterExpected = 0
│
├─ 00:00:05  期号 3365774 (相同)
│             距上次新期号: 5秒 < 210秒
│             ℹ️ 开奖前，正常，不计数
│
├─ 00:00:10  期号 3365774 (相同)
│             距上次新期号: 10秒 < 210秒
│             ℹ️ 开奖前，正常，不计数
│
├─ 00:03:00  期号 3365774 (相同)
│             距上次新期号: 180秒 < 210秒
│             ℹ️ 开奖前，正常，不计数
│
└─ 00:03:30  期号 3365775 (新期号！)
              🎉 获取到新期号: 3365774 → 3365775
              lastFetchTime = 00:03:30
              staleCountAfterExpected = 0
```

**结果**: ✅ 开奖前不切换数据源

---

### 场景2：开奖后数据源延迟（异常）

```
时间线:
├─ 00:00:00  获取到期号 3365774 (新期号)
│             lastFetchTime = 00:00:00
│
├─ 00:03:35  期号 3365774 (相同)
│             距上次新期号: 215秒 > 210秒 ✅ 已超过开奖时间
│             ⚠️ 开奖后返回旧数据，计数1
│
├─ 00:03:40  期号 3365774 (相同)
│             距上次新期号: 220秒 > 210秒
│             ⚠️ 开奖后返回旧数据，计数2
│
├─ 00:03:45  期号 3365774 (相同)
│             距上次新期号: 225秒 > 210秒
│             ⚠️ 开奖后返回旧数据，计数3
│             🔄 数据陈旧，切换到下一个数据源...
│
└─ 00:03:45  切换到 USA28/Database
              ✅ 尝试获取新数据
```

**结果**: ✅ 开奖后15秒内切换数据源

---

## 🎯 关键参数

| 参数 | 值 | 说明 |
|------|---|------|
| `DRAW_INTERVAL` | 210秒 | 开奖间隔（3分30秒） |
| `MAX_STALE_COUNT` | 3次 | 开奖后最多允许3次返回旧数据 |
| 检测间隔（开奖后） | 5秒 | 开奖后密集检测 |
| 切换时机 | 15秒 | 开奖后3次×5秒 = 15秒后切换 |

---

## 💡 判断逻辑详解

### 变量说明
```typescript
private lastFetchedIssue: string | null = null;     // 上次期号
private lastFetchTime: number = 0;                   // 获取新期号的时间戳
private staleCountAfterExpected = 0;                 // 开奖后陈旧计数
private readonly DRAW_INTERVAL = 210 * 1000;        // 210秒
```

### 判断流程
```typescript
const now = Date.now();
const isAfterExpectedDraw = 
  this.lastFetchTime > 0 && 
  (now - this.lastFetchTime) >= this.DRAW_INTERVAL;

if (this.lastFetchedIssue === latestIssue) {
  if (isAfterExpectedDraw) {
    // ⚠️ 开奖后仍返回旧数据 → 异常
    this.staleCountAfterExpected++;
    if (this.staleCountAfterExpected >= 3) {
      切换数据源();
    }
  } else {
    // ℹ️ 开奖前返回相同期号 → 正常
    不计数();
  }
} else {
  // 🎉 获取到新期号
  this.lastFetchTime = now;  // 重置时间
  this.staleCountAfterExpected = 0;  // 重置计数
}
```

---

## 📊 日志示例

### 开奖前（正常）
```
ℹ️ JND28 返回期号 3365774（开奖前，正常）
ℹ️ JND28 返回期号 3365774（开奖前，正常）
ℹ️ JND28 返回期号 3365774（开奖前，正常）
🎉 获取到新期号: 3365774 → 3365775
```

### 开奖后（异常切换）
```
⚠️ JND28 开奖后返回旧数据 (期号 3365774)，已连续 1/3 次
⚠️ JND28 开奖后返回旧数据 (期号 3365774)，已连续 2/3 次
⚠️ JND28 开奖后返回旧数据 (期号 3365774)，已连续 3/3 次
🔄 JND28 数据陈旧，切换到下一个数据源...
🔍 尝试数据源: USA28 (优先级: 2)
```

---

## ✅ 优势

### 1. 避免误切换
- ✅ 开奖前不切换（之前会误切）
- ✅ 只在真正需要时切换
- ✅ 减少不必要的数据源切换

### 2. 准确检测
- ✅ 基于时间判断，而不是简单计数
- ✅ 符合实际开奖规律
- ✅ 更智能的故障检测

### 3. 节省资源
- ✅ 减少不必要的API请求
- ✅ 降低服务器压力
- ✅ 提高系统效率

---

## 🔧 修改内容

### 文件：`lottery-data-source.manager.ts`

#### 1. 新增变量
```typescript
// ❌ 旧代码
private staleFetchCount = 0;

// ✅ 新代码
private lastFetchTime: number = 0;                   // 新增
private staleCountAfterExpected = 0;                 // 重命名
private readonly DRAW_INTERVAL = 210 * 1000;        // 新增
```

#### 2. 智能判断逻辑
```typescript
// 判断是否超过预期开奖时间
const isAfterExpectedDraw = 
  this.lastFetchTime > 0 && 
  (now - this.lastFetchTime) >= this.DRAW_INTERVAL;

if (相同期号 && isAfterExpectedDraw) {
  // 只有开奖后才计数
  this.staleCountAfterExpected++;
}
```

#### 3. 获取新期号时重置
```typescript
if (新期号) {
  this.lastFetchTime = now;  // 记录时间
  this.staleCountAfterExpected = 0;  // 重置计数
}
```

---

## 🧪 测试场景

### 1. 开奖前持续轮询
```
预期: 返回相同期号，不切换数据源
实际: ✅ 符合预期
```

### 2. 开奖后数据源延迟
```
预期: 连续3次返回旧数据，切换数据源
实际: ✅ 符合预期
```

### 3. 数据源恢复正常
```
预期: 获取到新期号，重置计数器
实际: ✅ 符合预期
```

### 4. 跨期号测试
```
期号1: 正常获取
期号2: 数据源延迟，切换
期号3: 主数据源恢复，重新使用
预期: ✅ 符合预期
```

---

## ⚠️ 注意事项

### 1. 时间精度
```
DRAW_INTERVAL = 210秒
实际开奖可能有±5秒误差
因此使用 >= 210秒 判断，而不是 > 210秒
```

### 2. 首次初始化
```
lastFetchTime = 0 时，isAfterExpectedDraw = false
首次获取新期号后，才开始计时
```

### 3. 系统重启
```
重启后 lastFetchTime = 0
第一次获取数据会重新初始化
不影响正常运行
```

---

**实现时间**：2025-11-29  
**优化类型**：智能化数据源切换  
**影响范围**：开奖数据同步逻辑  
**向下兼容**：✅ 是  
**状态**：✅ 已完成

