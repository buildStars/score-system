# 期号刷新时清空下注记录

## 问题描述

**现象：** 当期号从 3365420 刷新到 3365425 时，旧期号 3365420 的下注记录仍然显示在"当前期下注"面板中，没有被清空。

**影响：** 用户会看到已经结束的期号的下注记录，造成混淆。

---

## 解决方案

### 修改文件
`frontend-h5/src/views/Home.vue`

### 核心逻辑

在 `loadCurrentData()` 函数中添加期号变化检测：

```typescript
// 检测期号是否变化
const oldIssue = lotteryStore.currentIssue
const newIssue = statusData.currentPeriod

// 更新期号信息
lotteryStore.currentIssue = newIssue

// 如果期号变化了，清空当前期下注记录
if (oldIssue && oldIssue !== newIssue) {
  console.log('🔄 期号已更新:', oldIssue, '->', newIssue, '清空下注记录')
  currentIssueBets.value = null
}
```

### 完整流程

1. **记录旧期号**：在更新期号前，保存当前期号到 `oldIssue`
2. **获取新期号**：从 API 响应中获取新期号 `newIssue`
3. **检测变化**：比较 `oldIssue` 和 `newIssue`
4. **清空记录**：如果期号变化，将 `currentIssueBets.value` 设为 `null`
5. **重新加载**：在 `Promise.all` 中自动调用 `loadCurrentIssueBets()` 加载新期号的下注记录

---

## 代码变更

### 1. 添加期号变化检测和清空逻辑

```diff
  console.log('🕐 时间同步信息:', {
    服务器时间: statusData.serverTime,
    客户端时间: new Date().toISOString(),
    偏移量: `${serverTimeOffset.value}ms`,
    封盘时间: statusData.currentCloseTime,
    开奖时间: statusData.currentDrawTime,
  })
  
+ // 检测期号是否变化
+ const oldIssue = lotteryStore.currentIssue
+ const newIssue = statusData.currentPeriod
+ 
  // 更新期号信息
- lotteryStore.currentIssue = statusData.currentPeriod
+ lotteryStore.currentIssue = newIssue
+ 
+ // 如果期号变化了，清空当前期下注记录
+ if (oldIssue && oldIssue !== newIssue) {
+   console.log('🔄 期号已更新:', oldIssue, '->', newIssue, '清空下注记录')
+   currentIssueBets.value = null
+ }
```

### 2. 在数据加载时自动刷新下注记录

```diff
  // 同时获取用户信息、上期开奖结果和当前期下注
  await Promise.all([
    userStore.fetchUserInfo(),
    lotteryStore.fetchCurrentIssue(), // 获取上期开奖结果和系统公告
+   loadCurrentIssueBets(), // 加载当前期下注记录
  ])
```

### 3. 移除重复的加载调用

```diff
  onMounted(() => {
+   // loadCurrentData() 会自动加载 loadCurrentIssueBets()
    loadCurrentData()
-   loadCurrentIssueBets()
  })
```

---

## 执行时机

### 场景1：首次加载页面
```
onMounted
  └─> loadCurrentData()
        ├─> 获取期号 (例如: 3365425)
        ├─> oldIssue 为空，不清空记录
        └─> loadCurrentIssueBets() 加载当前期下注
```

### 场景2：开奖后刷新（期号变化）
```
onCountdownFinish (开奖倒计时结束)
  └─> loadCurrentData() (延迟3秒)
        ├─> oldIssue = 3365425
        ├─> newIssue = 3365426
        ├─> ✅ 检测到期号变化！
        ├─> currentIssueBets.value = null (清空旧记录)
        └─> loadCurrentIssueBets() (加载新期下注，通常为空)
```

### 场景3：封盘倒计时结束（期号不变）
```
onCountdownFinish (封盘倒计时结束)
  └─> 不调用 loadCurrentData()
        └─> 保持当前期下注记录不变
```

---

## 测试验证

### 测试步骤

1. **下注测试**
   ```
   - 访问首页
   - 登录 user1 / 123456
   - 查看当前期号（例如：3365425）
   - 下注 100 大
   - 验证：下注面板显示 "大 100分 X"
   ```

2. **期号刷新测试**
   ```
   - 等待开奖倒计时结束
   - 等待 3 秒后自动刷新
   - 验证：期号更新为新期号（例如：3365426）
   - 验证：下注面板被清空（不再显示旧期号的 "大 100分"）
   ```

3. **新期下注测试**
   ```
   - 在新期号下注 200 小
   - 验证：下注面板显示 "小 200分 X"
   - 刷新页面
   - 验证：下注面板仍然显示 "小 200分 X"（数据持久化）
   ```

### 预期结果

| 操作 | 期号 | 下注面板显示 |
|------|------|-------------|
| 初始加载 | 3365425 | 无 |
| 下注100大 | 3365425 | 大 100分 X |
| 开奖后刷新 | 3365426 | **清空** ✅ |
| 下注200小 | 3365426 | 小 200分 X |
| 再次开奖 | 3365427 | **清空** ✅ |

---

## 类型修复

### 问题
```typescript
currentIssueBets.value = []  // ❌ 类型错误
```

**错误信息：** 不能将类型"never[]"分配给类型"CurrentIssueBetsData | ... | null"

### 解决
```typescript
currentIssueBets.value = null  // ✅ 正确类型
```

---

## 日志输出

期号变化时的控制台输出：

```
🔄 期号已更新: 3365425 -> 3365426 清空下注记录
📡 加载当前期下注...
✅ 当前期下注加载成功: 0 条
```

---

## 优化总结

### ✅ 改进点

1. **期号变化检测**：通过比较新旧期号，准确识别期号变化
2. **自动清空记录**：期号变化时自动清空旧期下注记录
3. **自动重新加载**：清空后自动加载新期下注记录
4. **避免重复加载**：移除 `onMounted` 中的重复调用
5. **类型安全**：使用 `null` 而不是 `[]` 清空数据

### 📊 用户体验提升

- ✅ **清晰明确**：用户不会看到已结束期号的下注记录
- ✅ **实时更新**：新期号的下注记录自动加载
- ✅ **逻辑正确**：每个期号的下注记录独立管理
- ✅ **性能优化**：避免不必要的重复 API 调用

---

## 相关文件

- `frontend-h5/src/views/Home.vue` - 主要修改文件
- `frontend-h5/src/api/bet.ts` - 当前期下注 API
- `frontend-h5/src/stores/lottery.ts` - 期号状态管理

---

修改完成！🎉

