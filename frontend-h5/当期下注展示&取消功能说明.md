# 当期下注展示 & 可取消功能

## 功能概述

在首页投注页面顶部添加一个当期下注展示区域，用户可以实时查看本期已下注的所有玩法，并可以在封盘前取消任意玩法的下注。

## 功能特点

### 1. 展示位置
- 位于首页倒计时section之后、上期开奖结果之前
- 使用渐变紫色背景，醒目美观
- 只在有下注时显示，无下注时自动隐藏

### 2. 展示内容

#### 区域标题
- 显示"本期下注"标题
- 显示当前期号（如：第3364706期）

#### 下注列表
按玩法逐项展示：
- **玩法名称**：如"1000倍数"、"大"、"小单"等
- **下注积分**：显示该玩法的总下注金额（包含所有加注）
- **取消按钮**：每项右侧显示"X"图标，点击可取消该玩法的所有下注
- **封盘提示**：已封盘时显示"已封盘"提示，无法取消

#### 自动合并规则
- 同一玩法的多次下注会自动合并显示
- 例如：先下300倍数，后加200倍数 → 显示"500倍数"
- 组合下注同理：先下100小双，后加100小双 → 显示"小双 200分"

### 3. 取消规则

#### 取消条件
- 只能取消当前期的下注
- 只能在未封盘时取消（`canCancel: true`）
- 已封盘后无法取消（显示"已封盘"提示）

#### 取消流程
1. 点击某玩法右侧的"X"按钮
2. 弹出确认对话框：
   - 标题："确认取消"
   - 内容：显示要取消的玩法名称
   - 按钮：红色"确定取消"按钮、灰色"我再想想"按钮
3. 确认后调用后端API取消该玩法的所有下注
4. 取消成功后：
   - 显示成功提示（含退回积分数额）
   - 自动刷新用户积分
   - 自动刷新当期下注列表
   - 该玩法从列表中移除
5. 如所有玩法都被取消，整个区域自动隐藏

#### 退款规则
- 退回该玩法的所有下注积分
- 退回该玩法的所有手续费
- 退款金额 = 下注总额 + 手续费总额
- 退款后自动创建积分记录（类型：refund）

### 4. 实时刷新

#### 刷新时机
- 页面初始化时加载
- 每次下注成功后自动刷新
- 每次取消下注后自动刷新

#### 刷新内容
- 当期下注列表（按玩法合并）
- 用户当前积分
- 是否可以取消（根据封盘状态）

## 技术实现

### 后端API

#### 1. 获取当期下注API
```
GET /api/user/current-issue-bets
```

**响应数据：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "issue": "3364706",
    "bets": [
      {
        "betType": "multiple",
        "betContent": "1000",
        "totalAmount": 1500,
        "totalFee": 45,
        "betIds": [1, 2, 3]
      },
      {
        "betType": "combo",
        "betContent": "小双",
        "totalAmount": 500,
        "totalFee": 25,
        "betIds": [4, 5]
      }
    ],
    "canCancel": true
  }
}
```

#### 2. 取消下注API
```
POST /api/user/cancel-bet
```

**请求参数：**
```json
{
  "issue": "3364706",
  "betType": "multiple",
  "betContent": "1000"
}
```

**响应数据：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "message": "取消成功",
    "refundAmount": 1545,
    "newPoints": 101545
  }
}
```

### 前端实现

#### 组件结构
```vue
<div v-if="currentIssueBets && currentIssueBets.bets.length > 0" class="current-bets-section">
  <div class="section-title">
    <span class="title-text">本期下注</span>
    <span class="issue-text">{{ formatIssue(currentIssueBets.issue) }}</span>
  </div>
  <div class="bets-list">
    <div v-for="(bet, index) in currentIssueBets.bets" :key="index" class="bet-item">
      <div class="bet-content">
        <span class="bet-label">{{ formatBetDisplay(bet.betType, bet.betContent) }}</span>
        <span class="bet-amount">{{ formatMoney(bet.totalAmount) }} 分</span>
      </div>
      <van-icon v-if="currentIssueBets.canCancel" name="cross" size="18" class="cancel-icon" 
        @click="handleCancelBet(bet.betType, bet.betContent)" />
      <span v-else class="locked-hint">已封盘</span>
    </div>
  </div>
</div>
```

#### 核心函数

**1. 加载当期下注**
```typescript
const loadCurrentIssueBets = async () => {
  try {
    const res = await getCurrentIssueBets()
    currentIssueBets.value = res.data
  } catch (error) {
    console.error('加载当前期下注失败：', error)
    currentIssueBets.value = null
  }
}
```

**2. 取消下注**
```typescript
const handleCancelBet = async (betType: string, betContent: string) => {
  if (!currentIssueBets.value) return
  
  // 检查是否可以取消
  if (!currentIssueBets.value.canCancel) {
    showToast({ message: '已封盘，无法取消下注', type: 'fail' })
    return
  }

  try {
    // 确认取消
    await showConfirmDialog({
      title: '确认取消',
      message: `确定要取消 ${formatBetDisplay(betType, betContent)} 的下注吗？\n\n取消后将退回积分到您的账户。`,
      confirmButtonText: '确定取消',
      confirmButtonColor: '#ee0a24',
      cancelButtonText: '我再想想',
    })

    const res = await cancelBet({
      issue: currentIssueBets.value.issue,
      betType,
      betContent,
    })

    showToast({
      message: `✅ 取消成功！\n退回积分：${formatMoney(res.data.refundAmount)}`,
      type: 'success',
    })

    // 刷新用户信息和当前期下注
    await Promise.all([
      userStore.fetchUserInfo(),
      loadCurrentIssueBets(),
    ])
  } catch (error: any) {
    // 错误处理
  }
}
```

**3. 格式化玩法显示**
```typescript
const formatBetDisplay = (betType: string, betContent: string) => {
  if (betType === 'multiple') {
    return `${betContent}倍数`
  } else {
    return betContent
  }
}
```

### 样式设计

#### 渐变紫色背景
```scss
.current-bets-section {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: $border-radius-md;
  box-shadow: 0 2px 12px rgba(102, 126, 234, 0.3);
}
```

#### 下注项卡片
```scss
.bet-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 20px;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}
```

#### 取消按钮交互
```scss
.cancel-icon {
  color: #ee0a24;
  cursor: pointer;
  transition: transform 0.2s;

  &:hover {
    transform: scale(1.2);
  }

  &:active {
    transform: scale(0.9);
  }
}
```

## 后端业务逻辑

### 获取当期下注

#### 核心逻辑
1. 获取当前期号（智能判断，如当前期已开奖则使用下一期）
2. 查询该用户在当前期的所有 `pending` 状态下注
3. 按 `betType + betContent` 分组合并
4. 每组计算：
   - `totalAmount`：总下注金额
   - `totalFee`：总手续费
   - `betIds`：包含的所有下注记录ID
5. 返回合并后的列表和是否可取消标志

#### 代码示例
```typescript
async getCurrentIssueBets(userId: number) {
  // 1. 获取当前期号
  const lotteryStatus = await this.countdownService.getLotteryStatus()
  let currentIssue = lotteryStatus.currentPeriod
  
  // 检查当前期是否已开奖
  const currentResult = await this.prisma.lotteryResult.findUnique({
    where: { issue: currentIssue },
  })
  
  if (currentResult) {
    currentIssue = lotteryStatus.nextPeriod
  }

  // 2. 查询当前期的所有pending状态下注
  const bets = await this.prisma.bet.findMany({
    where: {
      userId,
      issue: currentIssue,
      status: 'pending',
    },
    orderBy: { createdAt: 'asc' },
  })

  // 3. 按玩法分组合并
  const groupedBets = new Map()
  for (const bet of bets) {
    const key = `${bet.betType}-${bet.betContent}`
    if (!groupedBets.has(key)) {
      groupedBets.set(key, {
        betType: bet.betType,
        betContent: bet.betContent,
        totalAmount: 0,
        totalFee: 0,
        betIds: [],
      })
    }
    const group = groupedBets.get(key)
    group.totalAmount += Number(bet.amount)
    group.totalFee += Number(bet.fee)
    group.betIds.push(bet.id)
  }

  // 4. 检查是否可以取消
  const betCheck = await this.countdownService.canPlaceBet()

  return {
    issue: currentIssue,
    bets: Array.from(groupedBets.values()),
    canCancel: betCheck.canBet,
  }
}
```

### 取消下注

#### 核心逻辑
1. 验证是否可以取消（未封盘）
2. 验证期号是否为当前期
3. 查询该玩法的所有 `pending` 状态下注
4. 计算需要退回的总积分（下注金额 + 手续费）
5. 使用事务：
   - 更新所有相关下注的状态为 `cancelled`
   - 退回积分到用户账户
   - 创建积分记录（类型：`refund`）
6. 返回退款结果

#### 代码示例
```typescript
async cancelBet(userId: number, issue: string, betType: string, betContent: string) {
  // 1. 验证是否可以取消
  const betCheck = await this.countdownService.canPlaceBet()
  if (!betCheck.canBet) {
    throw new BadRequestException('已封盘，无法取消下注')
  }

  // 2. 获取当前期号
  const lotteryStatus = await this.countdownService.getLotteryStatus()
  let currentIssue = lotteryStatus.currentPeriod
  const currentResult = await this.prisma.lotteryResult.findUnique({
    where: { issue: currentIssue },
  })
  if (currentResult) {
    currentIssue = lotteryStatus.nextPeriod
  }

  // 3. 验证期号
  if (issue !== currentIssue) {
    throw new BadRequestException('只能取消当前期的下注')
  }

  // 4. 查询该玩法的所有pending下注
  const bets = await this.prisma.bet.findMany({
    where: {
      userId,
      issue,
      betType,
      betContent,
      status: 'pending',
    },
  })

  if (bets.length === 0) {
    throw new BadRequestException('未找到该玩法的下注记录')
  }

  // 5. 计算退款金额
  const totalRefund = bets.reduce((sum, bet) => sum + Number(bet.amount) + Number(bet.fee), 0)

  // 6. 获取用户信息
  const user = await this.prisma.user.findUnique({ where: { id: userId } })
  if (!user) {
    throw new BadRequestException('用户不存在')
  }

  const newPoints = Number(user.points) + totalRefund

  // 7. 使用事务处理
  await this.prisma.$transaction(async (tx) => {
    // 更新下注状态
    await tx.bet.updateMany({
      where: { id: { in: bets.map(b => b.id) } },
      data: {
        status: 'cancelled',
        pointsAfter: newPoints,
        settledAt: new Date(),
      },
    })

    // 更新用户积分
    await tx.user.update({
      where: { id: userId },
      data: { points: newPoints },
    })

    // 创建积分记录
    await tx.pointRecord.create({
      data: {
        userId,
        type: 'refund',
        amount: totalRefund,
        balanceBefore: Number(user.points),
        balanceAfter: newPoints,
        relatedId: bets[0].id,
        relatedType: 'bet',
        remark: `取消下注退款：${issue} ${betType === 'multiple' ? betContent + '倍数' : betContent}`,
      },
    })
  })

  return {
    message: '取消成功',
    refundAmount: totalRefund,
    newPoints,
  }
}
```

## 用户体验优化

### 1. 视觉反馈
- 渐变紫色背景，与倒计时区域形成呼应
- 白色卡片式展示每个玩法，清晰易读
- 红色"X"按钮，醒目易点击
- 悬停和点击时的缩放动画，提升交互体验

### 2. 交互优化
- 确认对话框防止误操作
- 详细的提示信息（含退回积分数额）
- 自动刷新，无需手动操作
- 封盘后自动禁用取消功能

### 3. 性能优化
- 只在有下注时渲染区域
- 使用异步并发刷新（`Promise.all`）
- 错误处理完善，避免影响其他功能

## 测试场景

### 场景1：单次下注后展示
1. 用户下注"1000倍数"
2. 当期下注区域显示："1000倍数 1000分 X"
3. 点击"X"按钮
4. 确认取消
5. 提示"取消成功！退回积分：1030"
6. 区域消失（无其他下注）

### 场景2：多次加注合并展示
1. 用户下注"500倍数"
2. 区域显示："500倍数 500分 X"
3. 用户再次加注"500倍数"
4. 区域更新为："1000倍数 1000分 X"
5. 点击"X"取消
6. 退回所有积分和手续费

### 场景3：多玩法混合下注
1. 用户下注"1000倍数"
2. 用户下注"小双 500分"
3. 区域显示两个卡片：
   - "1000倍数 1000分 X"
   - "小双 500分 X"
4. 取消"1000倍数"
5. 只剩"小双 500分 X"
6. 再取消"小双"
7. 区域完全消失

### 场景4：封盘后无法取消
1. 用户下注"1000倍数"
2. 等待至封盘
3. "X"按钮变为"已封盘"提示
4. 点击提示无反应
5. 无法取消下注

### 场景5：跨期下注
1. 用户在3364706期下注
2. 等待至该期开奖
3. 系统自动切换到下一期3364707
4. 当期下注区域为空（上一期已结算）
5. 用户下注新一期
6. 区域显示新一期的下注

## 总结

当期下注展示 & 可取消功能为用户提供了更好的下注管理体验：

✅ **实时展示**：清晰显示本期所有下注
✅ **智能合并**：同一玩法自动合并显示
✅ **灵活取消**：封盘前可随时取消任意玩法
✅ **安全保障**：确认对话框防止误操作
✅ **全额退款**：退回下注金额和手续费
✅ **自动刷新**：无需手动操作，体验流畅

该功能与现有的下注系统完美集成，提升了用户的投注灵活性和控制感！ 🎉





