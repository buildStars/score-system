# 开奖同步机制优化方案 🚀

## 📋 问题发现

### 用户观察到的现象

```
开奖时间：15:23:30  (期号 3364877)
同步时间：15:24:00  (延迟30秒)
```

**延迟原因**：
- 定时同步任务是每3分钟执行一次
- 新期检测依赖倒计时服务的期号
- 倒计时服务期号更新每210秒才执行一次
- 导致新期检测无法及时发现新期

---

## 🔍 旧方案的问题

### 同步架构（修改前）

```
┌─────────────────────────────────────────┐
│ 同步服务 (LotterySyncService)          │
├─────────────────────────────────────────┤
│ 1. 定时同步：每3分钟                    │
│ 2. 新期检测：每30秒                     │
│    ├─ 获取倒计时服务的期号              │
│    ├─ 对比上次期号                      │
│    └─ 如果变化则同步                    │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│ 倒计时服务 (LotteryCountdownService)   │
├─────────────────────────────────────────┤
│ 1. 定期更新：每210秒 (Interval)         │
│ 2. 密集同步：开奖后10秒内每10秒         │
│ 3. 获取状态：检测倒计时为负时刷新      │
└─────────────────────────────────────────┘
         ↓
    第三方 API
```

### 核心问题

1. **循环依赖**：
   - 新期检测依赖倒计时服务
   - 倒计时服务依赖自己的定时任务
   - 导致新期检测失效

2. **触发点混乱**：
   - 倒计时服务有3个触发点（定期、密集、获取状态时）
   - 同步服务有2个触发点（定时、新期检测）
   - 职责不清，重复调用

3. **延迟问题**：
   - 完全依赖3分钟定时任务
   - 新期检测无法工作
   - 实际延迟可能长达3分钟

---

## ✅ 新方案设计

### 核心理念

**分工明确，职责单一**

1. **同步服务**：负责从第三方API获取数据并保存到数据库
2. **倒计时服务**：只负责读取数据库和计算倒计时

### 优化后的架构

```
┌─────────────────────────────────────────┐
│ 同步服务 (LotterySyncService)          │
├─────────────────────────────────────────┤
│ 1. 定时同步：每3分钟（兜底）            │
│ 2. 快速检测：每30秒调用一次同步         │
│    └─ 直接调用 syncLotteryData()       │
│       内部会检查是否已存在，避免重复    │
└─────────────────────────────────────────┘
         ↓
    第三方 API
         ↓
      数据库
         ↓
┌─────────────────────────────────────────┐
│ 倒计时服务 (LotteryCountdownService)   │
├─────────────────────────────────────────┤
│ 1. 定期更新：每210秒从API更新缓存       │
│ 2. 获取状态：直接使用缓存数据计算       │
│    └─ 不再触发刷新，只计算倒计时        │
└─────────────────────────────────────────┘
```

---

## 🔧 具体修改

### 1. 同步服务优化 ✅

**文件**: `score-system/backend/src/modules/lottery/lottery-sync.service.ts`

**修改前**：
```typescript
@Cron('*/30 * * * * *')
async checkNewIssue() {
  // 获取倒计时服务的期号
  const status = await this.countdownService.getLotteryStatus();
  const currentIssue = status.currentPeriod;

  // 如果期号变化了，说明新期开奖
  if (this.lastSyncedIssue && currentIssue !== this.lastSyncedIssue) {
    await this.syncLotteryData();
  }
}
```

**修改后**：
```typescript
@Cron('*/30 * * * * *')
async checkNewIssue() {
  // 直接调用同步，内部会检查是否已存在
  await this.syncLotteryData();
}
```

**优势**：
- ✅ 不依赖倒计时服务
- ✅ 直接检查第三方API
- ✅ 最大延迟30秒（而不是3分钟）

---

### 2. 倒计时服务简化 ✅

**文件**: `score-system/backend/src/modules/lottery/lottery-countdown.service.ts`

**删除的代码**：
- ❌ `checkDrawTime()` - 每10秒检查开奖时刻
- ❌ `calculateNextDrawTime()` - 计算下次开奖时间
- ❌ `denseSyncAfterDraw()` - 密集同步方法
- ❌ `getLotteryStatus()` 中的刷新逻辑

**保留的代码**：
- ✅ `syncLatestDraw()` - 每210秒定期更新
- ✅ `reloadSettings()` - 每5分钟重新加载配置
- ✅ `getLotteryStatus()` - 纯计算，不触发刷新

**获取状态逻辑**：
```typescript
// 修改前
if (diffSeconds <= 0) {
  this.logger.warn('倒计时已结束，尝试重新获取最新开奖数据');
  await this.fetchLatestDraw();  // ❌ 触发刷新
  return this.getLotteryStatus();  // ❌ 递归调用
}

// 修改后
if (diffSeconds <= 0) {
  // 使用估算值（等待定时任务同步）
  diffSeconds = this.DRAW_INTERVAL - (Math.abs(diffSeconds) % this.DRAW_INTERVAL);
  this.logger.debug(`倒计时为负，使用估算值: ${diffSeconds}秒（等待定时任务同步）`);
}
```

---

## 📊 同步时间对比

### 修改前

| 场景 | 同步时机 | 延迟 |
|-----|---------|------|
| 正常情况 | 3分钟定时任务 | 0-180秒 |
| 新期检测 | 每30秒检查期号变化 | ❌ 失效（依赖倒计时） |
| 密集同步 | 开奖后10秒内 | 0-10秒 |

**平均延迟**：**60-90秒**

### 修改后

| 场景 | 同步时机 | 延迟 |
|-----|---------|------|
| 快速检测 | 每30秒调用API | **0-30秒** |
| 兜底同步 | 3分钟定时任务 | 0-180秒 |

**平均延迟**：**15秒**  
**最大延迟**：**30秒** ✅

---

## 🎯 新方案的优势

### 1. 延迟大幅降低

```
旧方案：平均 60-90秒
新方案：平均 15秒
提升：4-6倍 ⚡
```

### 2. 架构更清晰

```
同步服务 = 负责获取和保存数据
倒计时服务 = 负责读取和计算

职责明确，互不干扰
```

### 3. 避免重复调用

```typescript
// syncLotteryData 内部有去重逻辑
const existing = await this.prisma.lotteryResult.findUnique({
  where: { issue: drawIssue },
});

if (existing) {
  console.log(`期号 ${drawIssue} 已存在，跳过`);
  continue;
}
```

**优势**：
- 每30秒调用一次不会导致重复保存
- 如果数据已存在，直接跳过
- 不浪费资源

### 4. 容错性强

```
快速检测（每30秒）
    ↓ 失败
定时同步（每3分钟）
    ↓ 兜底
确保数据最终同步
```

---

## 📝 工作流程示例

### 开奖时间轴

```
15:23:00  开奖周期开始 (3364876)
    |
    v
15:23:30  🎲 新期开奖！(3364877)
    |
    v
15:23:40  ⏰ 快速检测触发（+10秒）
    |     ├─ 调用API
    |     ├─ 发现新期 3364877
    |     ├─ 保存到数据库
    |     └─ ✅ 同步成功
    v
15:24:00  ⏰ 定时同步触发（3分钟）
    |     └─ 检查发现已存在，跳过
    v
15:24:10  ⏰ 快速检测触发（+40秒）
    |     └─ 检查发现已存在，跳过
    v
15:27:00  下一个开奖周期
```

**关键点**：
- ✅ 开奖后10秒同步成功
- ✅ 后续检测自动跳过（已存在）
- ✅ 不会重复保存

---

## 🚀 部署和验证

### 1. 重启服务

```bash
taskkill /F /IM node.exe
Start-Sleep -Seconds 2
cd D:\download\yunce\yunce\score-system\backend
pnpm start:dev
```

### 2. 观察日志

**开奖前**：
```
# 应该安静，不会频繁打日志
```

**开奖后30秒内**：
```
[LotterySyncService] ⏰ 快速检测触发
[LotterySyncService] 📡 开始同步开奖数据...
[LotteryService] ✓ 成功保存期号 3364877
[LotterySyncService] ✅ 同步成功！新增 1 条数据
```

**后续检测**：
```
[LotterySyncService] ⏰ 快速检测触发
[LotterySyncService] 📡 开始同步开奖数据...
[LotteryService] 期号 3364877 已存在，跳过
[LotterySyncService] ℹ️  没有新的开奖数据
```

### 3. 性能验证

**测试指标**：
- [ ] 开奖后30秒内数据库有新期数据
- [ ] 倒计时服务不再频繁调用API
- [ ] 不再出现递归死循环警告
- [ ] 日志清晰，无混乱信息

---

## 🎉 总结

### 核心改进

1. **同步延迟**：60-90秒 → **15秒平均，30秒最大**
2. **调用频率**：混乱 → **清晰固定（每30秒）**
3. **职责划分**：耦合 → **解耦（各司其职）**
4. **资源使用**：重复 → **高效（自动去重）**
5. **代码复杂度**：高 → **低（删除密集同步）**

### 架构优势

✅ **同步服务**：主动检测，每30秒一次  
✅ **倒计时服务**：被动计算，不触发同步  
✅ **数据库**：单一数据源  
✅ **去重机制**：避免重复保存

**现在开奖数据最多延迟30秒，系统响应更快了！** 🚀



