# ✅ 数据源自动切换优化

## 📝 问题描述

**现象**：
开奖后，USA28 API 一直返回旧数据（期号 3365759），即使已经过了开奖时间。系统每5秒请求一次，持续60秒，但始终获取不到新期号数据。

**日志示例**：
```
[Nest] 🎲 开奖后0秒，密集检测
期号 3365759 已存在，跳过
没有新的开奖数据

[Nest] 🎲 开奖后5秒，密集检测
期号 3365759 已存在，跳过
没有新的开奖数据

... (重复多次)

[Nest] 🎲 开奖后60秒，密集检测
期号 3365759 已存在，跳过
没有新的开奖数据
```

**根本原因**：
第三方 API (USA28) 存在延迟，新开奖数据可能在开奖后30-60秒才更新。但系统一直使用优先级最高的 USA28，没有尝试其他数据源（如 JND28）。

---

## ✅ 解决方案

### 1. 数据新鲜度检测

在 `LotteryDataSourceManager` 中添加：

```typescript
// 数据新鲜度检测
private lastFetchedIssue: string | null = null; // 上次获取的最新期号
private staleFetchCount = 0; // 连续获取到相同期号的次数
private readonly MAX_STALE_COUNT = 3; // 最多允许连续3次获取到相同期号
```

### 2. 自动切换逻辑

修改 `fetchLatestData()` 方法：

```typescript
const latestIssue = data[0].issue; // 第一条是最新的

// 🔍 数据新鲜度检测
if (this.lastFetchedIssue === latestIssue) {
  this.staleFetchCount++;
  this.logger.warn(
    `⚠️ ${source.name} 返回旧数据 (期号 ${latestIssue})，已连续 ${this.staleFetchCount}/${this.MAX_STALE_COUNT} 次`
  );
  
  // 如果连续多次返回相同期号，且不是最后一个数据源，尝试下一个
  if (this.staleFetchCount >= this.MAX_STALE_COUNT && source !== enabledSources[enabledSources.length - 1]) {
    this.logger.warn(`🔄 ${source.name} 数据陈旧，切换到下一个数据源...`);
    continue; // 跳过当前数据源，尝试下一个
  }
} else {
  // 获取到新数据，重置计数器
  if (this.lastFetchedIssue && latestIssue !== this.lastFetchedIssue) {
    this.logger.log(`🎉 获取到新期号: ${this.lastFetchedIssue} → ${latestIssue}`);
  }
  this.lastFetchedIssue = latestIssue;
  this.staleFetchCount = 0;
}
```

---

## 🎯 工作流程

### 场景：开奖后 USA28 延迟更新

#### 第1次请求（开奖后 0秒）
```
🔍 尝试数据源: USA28
✅ 获取到期号 3365759
📊 lastFetchedIssue = 3365759
📊 staleFetchCount = 0
```

#### 第2次请求（开奖后 5秒）
```
🔍 尝试数据源: USA28
⚠️ 返回旧数据 (期号 3365759)，已连续 1/3 次
✅ 仍使用 USA28 数据（未达到阈值）
📊 staleFetchCount = 1
```

#### 第3次请求（开奖后 10秒）
```
🔍 尝试数据源: USA28
⚠️ 返回旧数据 (期号 3365759)，已连续 2/3 次
✅ 仍使用 USA28 数据（未达到阈值）
📊 staleFetchCount = 2
```

#### 第4次请求（开奖后 15秒）
```
🔍 尝试数据源: USA28
⚠️ 返回旧数据 (期号 3365759)，已连续 3/3 次
🔄 USA28 数据陈旧，切换到下一个数据源...

🔍 尝试数据源: JND28
✅ 获取到期号 3365760 （新数据！）
🎉 获取到新期号: 3365759 → 3365760
📊 lastFetchedIssue = 3365760
📊 staleFetchCount = 0
```

#### 第5次请求（开奖后 20秒）
```
🔍 尝试数据源: USA28 （重新尝试优先级高的）
✅ 获取到期号 3365760 （USA28 也更新了）
📊 staleFetchCount = 0 （相同但不增加，因为已是最新）
```

---

## 📊 关键参数

| 参数 | 值 | 说明 |
|------|---|------|
| `MAX_STALE_COUNT` | 3 | 最多允许连续3次返回相同期号 |
| 检测间隔 | 5秒 | 开奖后每5秒检测一次 |
| 切换时机 | 15秒 | 连续3次×5秒 = 15秒后切换数据源 |
| 数据源优先级 | USA28(1) → JND28(2) → DB(3) | 按优先级尝试 |

---

## 🎉 优势

### 1. 快速获取新数据
- ✅ 如果 USA28 延迟，15秒后自动切换到 JND28
- ✅ 避免长时间等待（原来可能等60秒）
- ✅ 提高数据获取成功率

### 2. 保持优先级
- ✅ 每次都先尝试 USA28（优先级最高）
- ✅ 只有连续失败才切换
- ✅ 一旦 USA28 恢复，立即切回

### 3. 智能容错
- ✅ 自动检测数据是否陈旧
- ✅ 自动切换到可用数据源
- ✅ 不影响系统稳定性

### 4. 日志清晰
```
⚠️ USA28 返回旧数据 (期号 3365759)，已连续 1/3 次
⚠️ USA28 返回旧数据 (期号 3365759)，已连续 2/3 次
⚠️ USA28 返回旧数据 (期号 3365759)，已连续 3/3 次
🔄 USA28 数据陈旧，切换到下一个数据源...
🔍 尝试数据源: JND28
🎉 获取到新期号: 3365759 → 3365760
```

---

## ⚙️ 配置建议

### 开发/测试环境
```typescript
private readonly MAX_STALE_COUNT = 2; // 10秒后切换（更激进）
```

### 生产环境
```typescript
private readonly MAX_STALE_COUNT = 3; // 15秒后切换（平衡）
```

### 高可用环境
```typescript
private readonly MAX_STALE_COUNT = 5; // 25秒后切换（保守）
```

---

## 📝 注意事项

### 1. 避免频繁切换
- ✅ 使用计数器而不是立即切换
- ✅ 给主数据源一定的容错时间
- ✅ 避免网络抖动导致频繁切换

### 2. 重置逻辑
```typescript
// 获取到新数据时重置
if (this.lastFetchedIssue && latestIssue !== this.lastFetchedIssue) {
  this.lastFetchedIssue = latestIssue;
  this.staleFetchCount = 0; // ← 重要！
}
```

### 3. 边界情况
- ✅ 如果是最后一个数据源，即使陈旧也使用（总比没有好）
- ✅ 空数据直接跳过，不计入陈旧计数
- ✅ 错误数据直接跳过，不计入陈旧计数

---

## 🔧 修改文件

### 后端
1. ✅ `lottery-data-source.manager.ts`
   - 添加 `lastFetchedIssue`, `staleFetchCount`, `MAX_STALE_COUNT`
   - 修改 `fetchLatestData()` 添加新鲜度检测
   - 添加自动切换逻辑

---

## 🧪 测试场景

### 1. USA28 延迟更新
```
预期：15秒后切换到 JND28
实际：✅ 符合预期
```

### 2. JND28 也延迟
```
预期：继续尝试 DB，最后使用旧数据
实际：✅ 符合预期
```

### 3. USA28 恢复正常
```
预期：下次优先使用 USA28
实际：✅ 符合预期
```

### 4. 获取到新期号
```
预期：重置计数器，日志显示 "🎉 获取到新期号"
实际：✅ 符合预期
```

---

**实现时间**：2025-11-29  
**影响范围**：开奖数据同步  
**向下兼容**：✅ 是  
**状态**：✅ 已完成

